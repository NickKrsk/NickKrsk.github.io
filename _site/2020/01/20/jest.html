<p>Jest
Когда тестов и файлов с тестами становится много, возникают новые вопросы. Как группировать тесты? Как запустить на выполнение все тесты из одной директории? Если их очень много и они долгие, можно ли запустить их параллельно?</p>

<p>Для решения этих вопросов используют специальные тестовые фреймворки. Они помогают организовать структуру тестов и дают много полезного, например, удобный вывод. С большинством из этих возможностей мы познакомимся далее по курсу. В JavaScript мире наиболее популярен фреймворк Jest, разрабатываемый компанией Facebook. К слову, с помощью него мы тестируем все практики на Хекслете.</p>

<p>Ниже находится инструкция, в которой мы создадим с нуля npm-проект и добавим в него тесты.</p>

<p>Настройка и запуск
Создайте где-нибудь на вашем компьютере директорию с названием hexlet-jest. Зайдите в неё и выполните команду:</p>

<p>hexlet-jest $ npm init
Ответьте на все вопросы запущенного скрипта инициализации проекта. Убедитесь, что в корне проекта появился файл package.json.</p>

<p>Теперь добавим немного исходного кода. Создайте файл src/index.js с таким содержимым:</p>

<p>// Эта функция переворачивает переданную строку
export default str =&gt; str.split(‘’).reverse().join(‘’);
Jest — обычный npm-пакет, который локально подключается в разрабатываемый проект. Jest нужен только во время разработки, поэтому лучше установить его в секцию devDependencies:</p>

<h1 id="в-директории-с-проектом">В директории с проектом</h1>
<p>hexlet-jest $ npm i –save-dev jest
По умолчанию Jest не использует Babel, поэтому код с импортами внутри Jest не заработает. Для поддержки Babel нужно установить несколько дополнительных пакетов:</p>

<p>hexlet-jest $ npm i –save-dev babel-jest @babel/core @babel/preset-env
Далее создайте в корне проекта файл babel.config.js с таким содержимым:</p>

<p>module.exports = {
  presets: [[‘@babel/preset-env’, {targets: {node: ‘current’}}]],
};
После установки этих пакетов и настройки babel.config.js (подробнее в нашем курсе JS: Настройка окружения), Jest начнёт использовать Babel при запуске тестов. Никакая конфигурация больше не требуется.</p>

<p>Jest ожидает, что тесты находятся в директории <strong>tests</strong>, которую обычно располагают в корне проекта. Внутри этого каталога, можно создавать любую структуру, Jest найдёт все тесты, которые там лежат. Именование файлов с тестами должно быть таким: <name>.test.js. Где <name>, как правило, соответствует имени модуля, который тестируется.</name></name></p>

<p>Напишем наш первый тест. Создайте файл <strong>tests</strong>/index.test.js со следующими содержимым:</p>

<p>import reverse from ‘../src’;</p>

<p>test(‘reverse’, () =&gt; {
  expect(reverse(‘hello’)).toEqual(‘olleh’);
  expect(reverse(‘’)).toEqual(‘’);
});
Далее мы разберём структуру этого файла, а пока попробуем запустить тест на выполнение:</p>

<p>hexlet-jest $ npx jest
 PASS  <strong>tests</strong>/index.test.js
  ✓ reverse (11ms)</p>

<p>Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.166s
Ran all test suites.
Ура! Тесты прошли успешно.</p>

<p>Структура
Давайте ещё раз посмотрим на файл с тестом:</p>

<p>import reverse from ‘../src’;</p>

<p>test(‘reverse’, () =&gt; {
  const str = ‘hello’;
  expect(reverse(str)).toEqual(‘olleh’);
  expect(reverse(‘’)).toEqual(‘’);
})
Для тестов Jest предоставляет две глобальные функции: test и expect. Они доступны без какого-либо импорта, так как Jest делает их глобальными функциями.</p>

<p>Функция test нужна для описания конкретного теста и его проверок. Самих тестовых функций может быть любое количество. Первым параметром эта функция принимает произвольную строчку, которая должна описывать сам тест. Эта строчка потом отображается на экране во время запуска тестов для упрощения отладки.</p>

<p>hexlet-jest $ npx jest
 PASS  <strong>tests</strong>/index.test.js
  ✓ reverse (11ms) # название теста
Второй параметр — функция, внутри которой описан проверочный код. Обратите внимание на то, что этот код не выполняется сразу. Функция test добавляет его внутри Jest, который уже решает как и когда запускать тесты. Это позволяет проводить различные оптимизации например, выполнять тесты параллельно.</p>

<p>Самое необычное в этом коде — проверки. Jest использует “матчеры” (matchers). Это утверждения, имеющие особую структуру, напоминающую обращение к объекту. Общий принцип работы матчеров такой:</p>

<p>Вызывается функция expect куда передаётся актуальное (фактическое) значение.
На результате, возвращаемом функцией expect, вызывается подходящий матчер, например, toEqual.
Матчеры позволяют читать текст, практически, как английский язык:</p>

<p>// Ожидается, что результат выражения reverse(‘hello’) равен ‘olleh’
expect(reverse(‘hello’)).toEqual(‘olleh’);
Подробнее о матчерах в следующем уроке.</p>

<p>Одна из приятнейших особенностей Jest — то, как он выводит сообщения о проваленных проверках. Попробуйте внести ошибку в исходную функцию и запустите тесты заново:</p>

<p>hexlet-jest$ npx jest
 FAIL  <strong>tests</strong>/index.test.js
  ✕ reverse (9ms)</p>

<p>● reverse</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expect(received).toEqual(expected) // Object.is equality

Expected: "olleh"
Received: "o|l|l|e|h"

  3 | test('reverse', () =&gt; {
  4 |   const str = 'hello';
&gt; 5 |   expect(reverse(str)).toEqual('olleh');
    |                        ^
  6 | })
  7 |

  at Object.toEqual (__tests__/index.test.js:5:24)
</code></pre></div></div>

<p>Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        1.683s
Ran all test suites.
В этом выводе показаны не только ожидаемое и фактическое значение, но и исходный код файла с тестами с указанием на конкретную проверку. Это невероятная и очень полезная фишка, которая значительно ускоряет анализ результатов тестирования и помогает в отладке.</p>

<p>Самостоятельная работа
Выполните все шаги из этого урока
Залейте код на Гитхаб</p>
